# -*- coding: utf-8 -*-
"""Galois-F21.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v5BbwMrvYp9m2i0Q2nssMXBg4ybUZpqj
"""

#This code generate polynomials of degree 7 with galois group F21
# ===================== F21 (C7 ⋊ C3) SEPTIC GENERATOR — ONE FILE =====================
# Paste this whole cell into a fresh Sage session (spaces only; no tabs).

from sage.all import *

# ---- Dickson polynomials of the first kind ------------------------------------------
# D_0(x,a)=2, D_1(x,a)=x, D_n = x*D_{n-1} - a*D_{n-2}
def dickson_D(n, a):
    R.<x> = QQ[]
    if n == 0: return R(2)
    if n == 1: return x
    Dm2, Dm1 = R(2), x
    for _ in range(2, n+1):
        Dk = x*Dm1 - R(a)*Dm2
        Dm2, Dm1 = Dm1, Dk
    return Dm1.change_ring(ZZ)

# ---- Flip+scale transform: F(x) = x^deg * f(scale/x), done coefficient-wise ----------
def flip_scale(f, scale=1):
    R = f.parent(); x = R.gen()
    d = f.degree()
    coeffs = f.list()          # [a0,...,ad] ascending
    F = R(0); c = ZZ(scale)
    for k, ak in enumerate(coeffs):
        F += ZZ(ak) * (c**k) * (x**(d - k))
    if F != 0:
        cont = gcd(F.list())
        if cont != 0:
            F //= cont
        if F.leading_coefficient() < 0:
            F = -F
    return F

# ---- Frobenius sieve for F21: need [1,3,3] and [7] mod primes -----------------------
def frobenius_sieve_F21(f, primes=(5,7,11,13,17,19,23,29)):
    if f.degree() != 7 or not f.is_irreducible():
        return (False, False)
    disc = ZZ(f.discriminant())
    saw133 = False; saw7 = False
    for p in primes:
        if disc % p == 0:
            continue
        parts = sorted(g[0].degree() for g in f.change_ring(GF(p)).factor())
        if parts == [1,3,3]: saw133 = True
        if parts == [7]:     saw7   = True
        if saw133 and saw7:  break
    return (saw133, saw7)

# ---- Exact certification (on QQ): |Gal| = 21? ---------------------------------------
def certify_F21(f, try_exact=True):
    s133, s7 = frobenius_sieve_F21(f)
    if not (s133 and s7):
        return "not F21", None
    if not try_exact:
        return "probable F21", None
    try:
        fQ = f.change_ring(QQ)           # IMPORTANT: galois_group() needs QQ[x]
        G  = fQ.galois_group()
        return ("F21", G) if G.order()==21 else ("not F21", G)
    except RuntimeError:
        return "probable F21", None

# ---- Main paper-based constructor (p=7) ---------------------------------------------
# S = u^2 + 7 v^2, with u,v ≠ 0 and 7 ∤ u,v.
# f(x) = D_7(x,S) - 2 u S^3  (integer polynomial, degree 7).
# Optionally apply flip_scale(f, 2) to get a compact model (often the classic shape).
def F21_from_Dickson(u, v, compact=True, certify=True):
    u = ZZ(u); v = ZZ(v)
    if u == 0 or v == 0 or u % 7 == 0 or v % 7 == 0:
        raise ValueError("Require u,v ≠ 0 and 7 ∤ u,v.")
    S  = u*u + 7*v*v
    R.<x> = ZZ[]
    D7 = dickson_D(7, S)
    f  = (D7 - 2*u*(S**3)).change_ring(ZZ)
    f0 = f if not compact else flip_scale(f, scale=2)
    tag, G = certify_F21(f0, try_exact=certify)
    return f0, tag

# ---- Batch harvest over a small (u,v) box ------------------------------------------
def harvest_F21_Dickson(u_max=3, v_max=3, compact=True, certify=True, verbose=True):
    hits = []
    for u in range(-u_max, u_max+1):
        for v in range(-v_max, v_max+1):
            if u == 0 or v == 0 or u % 7 == 0 or v % 7 == 0:
                continue
            try:
                f, tag = F21_from_Dickson(u, v, compact=compact, certify=certify)
            except Exception:
                continue
            if not f.is_irreducible():
                continue
            if tag != "not F21":
                hits.append((u, v, f, tag))
                if verbose:
                    print(f"({u},{v})  {tag}:  {f}")
    return hits

# ---- Save to CSV (choose coefficient order) -----------------------------------------
def save_hits_csv(hits, path="F21_from_Dickson.csv", order="asc"):
    import csv
    with open(path, "w", newline="", encoding="utf-8") as fout:
        w = csv.writer(fout)
        w.writerow(["u","v","Polynomial","GroupTag","CoeffTuple"])
        for u,v,f,tag in hits:
            coeffs = f.list()                      # [a0,...,a7]
            if order == "desc":
                coeffs = list(reversed(coeffs))    # [a7,...,a0]
            w.writerow([u, v, str(f), tag, tuple(coeffs)])

# =============================== EXAMPLE USAGE =======================================
# 1) Single example at (u,v)=(1,1). With compact=True, this often matches the classic shape.
f11, tag11 = F21_from_Dickson(1, 1, compact=True, certify=True)
print("Example (u,v)=(1,1):", f11)
print("Tag:", tag11)

# 2) Harvest a batch; increase u_max, v_max for more hits.
hits = harvest_F21_Dickson(u_max=3, v_max=3, compact=True, certify=True, verbose=True)
print(f"Collected {len(hits)} candidates.")

# 3) Save (set order='desc' if your DB uses [a7,...,a0])
save_hits_csv(hits, path="F21_from_Dickson.csv", order="asc")
print("Saved to F21_from_Dickson.csv")